// Auto-generated TypeScript SDK
// Do not modify manually.

import { InMemoryContext } from './context';
import { ApiError } from './error';
import { toApiType, toClientType } from './utils';
import { RequestInterceptor, ResponseInterceptor, InterceptorManager } from './interceptors';

const SDK_VERSION = 'unset';

export class GoCartSDK {
  private baseUrl: string;

  public context: InMemoryContext;
  public interceptors: {
    request: InterceptorManager<RequestInterceptor>;
    response: InterceptorManager<ResponseInterceptor>;
  };

  constructor(baseUrl: string = 'https://api.orbita.al') {
    this.baseUrl = baseUrl;
    this.context = new InMemoryContext();
    this.interceptors = {
      request: new InterceptorManager<RequestInterceptor>(),
      response: new InterceptorManager<ResponseInterceptor>()
    };
  }

  /**
   * Format filter values, converting camelCase strings to snake_case
   * @private
   */
  private formatFilterValue(value: any): string {
    let formattedValue = String(value);
    // Convert camelCase string values to snake_case
    if (typeof value === 'string' && formattedValue !== formattedValue.toLowerCase()) {
      formattedValue = formattedValue.replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase();
    }
    return formattedValue;
  }

  /**
   * Execute a request with interceptor support and retry capability
   * @private
   */
  private async executeRequest(url: string, options: RequestInit): Promise<Response> {
    let finalUrl = url;
    let currentOptions = { ...options };

    // Apply request interceptors
    for (const interceptor of this.interceptors.request.interceptors) {
      const result = await interceptor(currentOptions, finalUrl);
      if (result) {
        if (result.options) currentOptions = result.options;
        if (result.url) finalUrl = result.url;
      }
    }

    // Make the request
    let response = await fetch(finalUrl, currentOptions);

    // Apply response interceptors
    for (const interceptor of this.interceptors.response.interceptors) {
      const result = await interceptor(response, currentOptions, finalUrl);
      if (result) {
        // Check if the interceptor returned a retry request
        if (this.isRetryRequest(result)) {
          // Recursively execute the retry request
          return this.executeRequest(result.url, result.options);
        } else {
          // Replace the response with the modified one
          response = result;
        }
      }
    }

    return response;
  }

  /**
   * Type guard to check if the result is a RetryRequest
   * @private
   */
  private isRetryRequest(result: Response | RetryRequest): result is RetryRequest {
    return (result as RetryRequest).url !== undefined && (result as RetryRequest).options !== undefined;
  }

  /**
   * listItems
   * @param params ListItemsParams
   * @param options Optional request configuration including abort signal
   * @returns Promise<any>
   */
  public async listItems(params: ListItemsParams = {}, options?: { signal?: AbortSignal }): Promise<any> {
    const url = `${this.baseUrl}/items`;
    let requestOptions: RequestInit = {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'x-gocart-sdk-version': SDK_VERSION,
        // Add other headers like authentication here
      },
      signal: options?.signal,
    };
    if (params.totalCount) {
      requestOptions.headers = {
        ...requestOptions.headers,
        'Collection-Total': 'include'
      }
    }
    const queryString = new URLSearchParams();
    if (params.filter) {
      if (params.filter["createdAt"] !== undefined && params.filter["createdAt"] !== null) {
        const dateRange = params.filter["createdAt"];
        if (typeof dateRange === 'object' && dateRange !== null) {
          if (dateRange.eq) { queryString.append('filter[created_at]', `${dateRange.eq.toISOString()}`); }
          if (dateRange.gte) { queryString.append('filter[created_at]', `>=${dateRange.gte.toISOString()}`); }
          if (dateRange.gt) { queryString.append('filter[created_at]', `>${dateRange.gt.toISOString()}`); }
          if (dateRange.lte) { queryString.append('filter[created_at]', `<=${dateRange.lte.toISOString()}`); }
          if (dateRange.lt) { queryString.append('filter[created_at]', `<${dateRange.lt.toISOString()}`); }
        }
      }
      if (params.filter["updatedAt"] !== undefined && params.filter["updatedAt"] !== null) {
        const dateRange = params.filter["updatedAt"];
        if (typeof dateRange === 'object' && dateRange !== null) {
          if (dateRange.eq) { queryString.append('filter[updated_at]', `${dateRange.eq.toISOString()}`); }
          if (dateRange.gte) { queryString.append('filter[updated_at]', `>=${dateRange.gte.toISOString()}`); }
          if (dateRange.gt) { queryString.append('filter[updated_at]', `>${dateRange.gt.toISOString()}`); }
          if (dateRange.lte) { queryString.append('filter[updated_at]', `<=${dateRange.lte.toISOString()}`); }
          if (dateRange.lt) { queryString.append('filter[updated_at]', `<${dateRange.lt.toISOString()}`); }
        }
      }
      if (params.filter["name"] !== undefined && params.filter["name"] !== null) {
        const value = params.filter["name"];
        queryString.append('filter[name]', this.formatFilterValue(value));
      }
    }
    let finalUrl = queryString.toString() ? `${url}?${queryString.toString()}` : url;
    requestOptions = this.context.setHttpRequestHeaders(requestOptions);
    const response = await this.executeRequest(finalUrl, requestOptions);

    if (response.status === 204) {
      return {} as any;
    }

    if (!response.ok) {
      const errMessage = await response.json();
      const err = toClientType(errMessage);
      throw new ApiError(err.code, err.message, err.fieldErrors);
    }
    const data = await response.json();
    // Transform keys to camelCase and recursively convert nested objects
    return toClientType(data);
  }

}
